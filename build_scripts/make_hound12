#!/bin/bash
# Hound 12 aka `A sed is fine too.`
# Macarthur Inbody <mdi2455@email.vccs.edu>
# AGPLv3
# 2019 -
# This flag requires them to delete a certain padding character from a string, only print only those lines that were modified
# that way they're using regex but are also only showing certain ones. Also this is showing them some non-standard views
# of sed.
#
if [[ $# -lt 1 ]];then
    level=11;
else
    level=$1;
fi
pattern_code='';
selected_pattern='';
function select_random_regex(){
    selected_pattern='';
    local tmp='';
    pattern_code=$(( $RANDOM  & 8 ));
    case $pattern_code in
        0)
            selected_pattern=' ';
        ;;
        1)
            selected_pattern=';'
        ;;
        2)
            selected_pattern='*';
        ;;
        3)
            selected_pattern='%';
        ;;
        4)
            selected_pattern='#';
        ;;
        5)
            selected_pattern='!';
        ;;
        6)
            selected_pattern='.';
        ;;
        7)
            selected_pattern='^';
        ;;
        8)
            tmp=$(( ($RANDOM  & 25 ) + 65 ));
            tmp=$( perl -e "printf '%c',$tmp;" );
            selected_pattern="$tmp";
        ;;
    esac
}

function sed_regex_pattern(){
    local selected_pattern=$1;
    local pattern_code=$2;
    local str=$3;
    if [[ $pattern_code -le 7 ]];then
        pattern_code='\'"$selected_pattern";
    fi

    echo "$str" | sed -e "s/\([a-z0-9]\)/\1$selected_pattern/g";
}
function sed_regex_help(){
base_str='You need to use a regex pattern that replaces all instances of'
extra_str0='';
base_str_end='. Then you need to make sure sed only shows changed lines. And finally only print the line ';
local code=$1;
local pattern=$2;
local line=$3;
    if [[ $code = 0 ]];then
        extra_str0='spaces';
    elif [[ $code = 8 ]];then
        extra_str0="the Uppercase letter:$pattern"
    else
        extra_str0="the special character:'$pattern'"
    fi
    printf '%s\n' "$base_str $extra_str0$base_str_end$line";
}

#the library of build functions.
source build_functions;
#seed_random $level;
#the dictionary file that we're using to get our words from.
#this will be set to a global variable DICTIONARY from the main script once the whole
#build system is done.
password_dict='../dict/passwords_dict';
#get the length of the dictionary file.
#in the future this'll be calculated once from the main build script and then the string
#DICTIONARY_LEN will be set to this value.
password_dict_len=2007;
#set the encoding. In future versions this'll be hardcoded from the main script.
#this is to make sure tha all hashes are b32 encoded.
HASH_ENCODING='b32';

WORD_ARRAY=(36 37 1 2 3 4 38);
chosen_word=${WORD_ARRAY[$(( $RANDOM & 6 ))]};
FLAG_HOUND=$( make_semistatic_flag $chosen_word);
select_random_regex;
CORRECT_REGEX_CODE=$pattern_code;
CORRECT_REGEX_PATTERN=$selected_pattern;
NUM_LINES=$(( ($RANDOM & 45) + 70 ));
correct_line=$(( ($RANDOM & 25 ) + 25 ));
tmp=$(( $RANDOM & 1 ));
if [[ $tmp = 1 ]];then
    false_line=$(( $correct_line + ($RANDOM  & 20 )));
else
    false_line=$(( $correct_line - ($RANDOM & 25) ));
fi
i=0;
while [[ $correct_line -eq $false_line ]];do
    case $tmp in
        1)
            false_line=$(( $correct_line + ($RANDOM & 20 )));
        ;;
        0)
            false_line=$(( $correct_line - ($RANDOM & 25) ));
        ;;
    esac
    i=$(( $i + 1 ));
done
echo 'i:'$i;
tmp_file=/tmpdownload/tmp_12;
printf '' > $tmp_file;
echo "$selected_pattern";
echo "cl:$correct_line";
echo "fl:$false_line";
echo "high_low:$tmp";
echo "$FLAG_HOUND";
capture_str='';
tmp='';
NUM_LINE=102;
for ((i=0;i<$NUM_LINES;++i)){
    str=$( make_false_flag $password_dict $password_dict_len );
    select_random_regex;
    if [[ $i = $correct_line ]];then
        #printf '%s\n' "`(sed_regex_pattern $CORRECT_REGEX_PATTERN $CORRECT_REGEX_CODE $FLAG_HOUND )`" >> $tmp_file;
        capture_str="$capture_str"`( sed_regex_pattern "$CORRECT_REGEX_PATTERN" $CORRECT_REGEX_CODE $FLAG_HOUND )`'\n';
    elif [[ $i = $false_line ]];then
        #printf '%s\n' "`(sed_regex_pattern $CORRECT_REGEX_PATTERN $CORRECT_REGEX_CODE $str )`" >> $tmp_file;
        capture_str="$capture_str"`( sed_regex_pattern "$CORRECT_REGEX_PATTERN" $CORRECT_REGEX_CODE $FLAG_HOUND )`'\n';
    else
        #printf '%s\n' "`(sed_regex_pattern $selected_pattern $pattern_code $str )`" >> $tmp_file;
        capture_str="$capture_str"`(sed_regex_pattern "$selected_pattern" $pattern_code $str )`'\n';
    fi
}
echo -en "$capture_str" >> $tmp_file;
correct_line=$(( $correct_line + 1 ));
sed_regex_help $CORRECT_REGEX_CODE "$CORRECT_REGEX_PATTERN" "$correct_line";
