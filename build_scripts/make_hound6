#!/bin/bash
#Hound 6 requires them to write their first bash script to bruteforce a pin and then cat that data to a program which'll give them the data back. But it only accepts the pin as a base64 encoded file.
#Macarthur Inbody <mdi2455@email.vccs.edu> (C) 2019-

#TODO: Look into additional options.
HOUND6_FLAG=$( echo 'Phineas the Fox' | openssl dgst -sha1 -binary | base64 | tr -d '=');
HOUND6_STR='The flag is ';
i=0;
j=0;
#HOUND6_FLAG l0pMty8KC2HxqKBni+XzWWm7jfk
#Number of directories.
directory_number=10;
#number of files per directory
file_number=5;
filename_arr=('.-' '-~' '-.' '.~');
filename_arr_len=${#filename_arr[*]};
filename='';
endname_arr=('filename' 'files' 'texts' 'flags');
endname_arr_len=${#endname_arr[*]};
suffix_arr=('.txt' '.dat' '.bin' '.hex' '.file' '.secrets');
suffix_arr_len=${#suffix_arr[*]};
suffix='';
dirname_arr=('.secrets' '.filthy_lucre' '.files' '.information' '.top_secret' '.hidden' '.mystery' '.hidden_treasures' '.maybeinhere' '.treasure_chest');
dirname_arr_len=${#dirname_arr[*]};
dirname='';
#the permissions in numeric form.
correct_permissions=751;
permission_array=(750 777 760 755 701);
permission_array_len=${#permission_array[*]};
file_type_correct='text';
file_type_arr=('binary' 'text' 'zero');
file_type_arr_len=${#file_type_arr[*]};
#the file size for the correct one7
correct_size=1337
#padding string function $(printf "%${<bytes_to_pad>}s" "<string>");
file_size_array=(33 1336  29 1338 1339);
file_size_array_len=${#file_size_array[*]};
size=0;
#the owner user id/name.
#1007=hound6
correct_owner=1007
owner_array=(1005 1006 1003 1000 1001 1002 1003);
owner_array_len=${#owner_array[*]};
owner=0;
#1006=hound5 group
correct_group=1006
group=0;
group_array=(1003 1004 1005 1007);
group_array_len=${#group_array[*]};
#the amount of partial matches to include by default it's 1 per directory.
#with the remaining files have random bits of the pattern correct.
red_herrings=directory_number;
#this assumes that file that is correct is counting from 0 like normal.
#this is set for each directory as the file that will be correct.
#the redherring will always be selected as a value that is this value +1 but then
#it wraps around.
correct_file=$(( ($RANDOM % ($file_number*$directory_number)) ));
l=0;
red_herring_file=$(( $RANDOM % $file_number ));
if [[ $red_herring_file -gt $(( $file_number - 1 )) ]];
then
red_herring_file=0;
red_herring_file2=$(( $RANDOM % $file_number));
fi

if [[ $red_herring_file2 -gt $(( $file_number - 1 )) ]];
then
red_herring_file2=0;
fi
if [[ $red_herring_file2 -eq $red_herring_file ]];then
    red_herring_file2=$(($red_herring_file+1));
fi
if [[ $red_herring_file2 -gt $(( $file_number - 1 )) ]];
then
red_herring_file2=0;
fi
if [[ $red_herring_file2 -eq $red_herring_file ]];then
    red_herring_file2=$(($red_herring_file+1));
fi
function red_herring_options(){
	incorrect_file_metadata=$(( $RANDOM % 4));
	local permission=751;
	local owner=1007;
	local group=1006;
	local file_size=1337;

	case $incorrect_file_metadata in
	0)
	    permission=${permission_array[$(( $RANDOM % $permission_array_len ))]};
	;;
	1)
	    group=${group_array[$(( $RANDOM % $group_array_len ))]};
	;;
	2)
	   file_size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
	;;
	3)
	   owner=${owner_array[$(( $RANDOM % $owner_array_len))]};
	;;
	esac
#	read -r -a options_array <<< "$permission $owner $group $file_size";
	echo "$permission $owner $group $file_size";
}
function make_false_file(){

    #local FILE_CONTENTS;
    local tmp_str=$(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '=');
    case $file_type in
        'text')
            printf "%${size}s\n" "$HOUND6_STR $tmp_str" > "$filename$j$suffix";
        ;;
        'binary')
            dd if=/dev/urandom bs=1 count=$size status=none of="$filename$j$suffix";
        ;;
        'zero')
            dd if=/dev/zero bs=1 count=$size status=none of="$filename$j$suffix";
            ;;
    esac
}

rm -Rvd tmp;
mkdir tmp;
cd tmp;
arr='';
tmp_str='';
FILE_CONTENTS='';
random_number=$(( $RANDOM % $dirname_arr_len ));

echo $correct_file;
echo $red_herring_file;
echo $red_herring_file2;
tmp_herring=$red_herring_file;
tmp_herring2=$red_herring_file2;
for ((i=0; i < $directory_number; i++)){
    dirname=${dirname_arr[$(( $RANDOM % $dirname_arr_len )) ]};
    mkdir -v "$dirname$i";
    chmod 777 "$dirname$i";
    cd "$dirname$i";
    filename=${filename_arr[$(($RANDOM % $filename_arr_len))]}${endname_arr[$(($RANDOM % $endname_arr_len))]};
    suffix=${suffix_arr[$(($RANDOM % $suffix_arr_len))]};
    for (( j=0; j < file_number; j++ )){
    size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
    owner=${owner_array[$(( $RANDOM % $owner_array_len ))]};
    group=${group_array[$(( $RANDOM % $group_array_len ))]};
    permission=${permission_array[$(( $RANDOM % $permission_array_len))]};

    echo $l;
        if [ $l -eq $correct_file ]; then
            #FILE_CONTENTS=$(printf "%${correct_size}s\n" "$HOUND6_STR $HOUND6_FLAG");
            printf "%${correct_size}s\n" "$HOUND6_STR $HOUND6_FLAG" > "$filename$j$suffix";
            echo 'correct_file'"$filename$j$suffix";
            owner=$correct_owner; group=$correct_group; permission=$correct_permissions;
            tmp_herring=$red_herring_file; tmp_herring2=$red_herring_file2;
            if [[ $j -eq $red_herring_file ]]; then
                tmp_herring=$(($tmp_herring+1));
            elif [[ $j -eq $red_herring_file2 ]]; then
                tmp_herring2=$(($tmp_herring2+1))
            fi
            if [[ $tmp_herring > $(( $file_number - 1 )) ]];then
                tmp_herring=0;
            fi
            if [[ $tmp_herring -eq $tmp_herring2 ]];then
                tmp_herring2=$(($tmp_herring2+1));
            fi
            if [[ $red_herring_file2 > $(( $file_number - 1 )) ]];then
                tmp_herring2=0;
            fi
            if [[ $tmp_herring -eq $tmp_herring2 ]];then
                tmp_herring2=$(($tmp_herring2+1));
            fi
        elif [ $j -eq $red_herring_file ]; then
            read -r -a arr <<< $(red_herring_options);
            echo 'rh1:'${arr[@]};
            permission=${arr[0]}; owner=${arr[1]}; group=${arr[2]}; size=${arr[3]};
            tmp_str=$(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '=');
            #FILE_CONTENTS=$(printf "%${size}s\n" "$HOUND6_STR $tmp_str");
            printf "%${size}s\n" "$HOUND6_STR $tmp_str" > "$filename$j$suffix";
        elif [[ $j -eq $tmp_herring_file2 ]]; then
            read -r -a arr <<< $(red_herring_options);
            echo 'rh2:'${arr[@]};
            permission=${arr[0]}; owner=${arr[1]}; group=${arr[2]}; size=${arr[3]};
            tmp_str=$(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '=');
            #FILE_CONTENTS=$(printf "%${size}s\n" "$HOUND6_STR $tmp_str");
            printf "%${size}s\n" "$HOUND6_STR $tmp_str" > "$filename$j$suffix";
        else
            echo 'other';
            file_type=${file_type_arr[$(($RANDOM % file_type_arr_len))]};
            #FILE_CONTENTS=$(make_false_file $file_size $file_type);
            make_false_file;
        fi

        echo "$filename$j$suffix";
        echo "$owner:$group";
        chown "$owner:$group" ./"$filename$j$suffix";
        echo "$permission";
        chmod "$permission" ./"$filename$j$suffix";
        l=$((l+1));
    }
    cd ..;

    #random_number=$(( $random_number+1 ));
    #if [[ $random_number -ge $dirname_arr_len ]];then
    #    random_number=0;
    #fi
}


#false flag function to make a string that looks like the legit one.
#this is used for the redherring's if the length matches up.
# $(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '='); 

