#!/bin/bash
#Hound 6 requires them to write their first bash script to bruteforce a pin and then cat that data to a program which'll give them the data back. But it only accepts the pin as a base64 encoded file.
#Macarthur Inbody <mdi2455@email.vccs.edu> (C) 2019-

#TODO: Look into additional options.
HOUND6_FLAG=$( echo 'Phineas the Fox' | openssl dgst -sha1 -binary | base64 | tr -d '=');
HOUND6_STR='The flag is ';
i=0;
j=0;
#HOUND6_FLAG l0pMty8KC2HxqKBni+XzWWm7jfk
#Number of directories.
directory_number=3;
#number of files per directory
file_number=5;
filename_arr=('.-' '-~' '-.' '.~');
filename_arr_len=${#filename_arr[*]};
filename='';
endname_arr=('filename' 'files' 'texts' 'flags');
endname_arr_len=${#endname_arr[*]};
suffix_arr=('.txt' '.dat' '.bin' '.hex' '.file' '.secrets');
suffix_arr_len=${#suffix_arr[*]};
suffix='';
dirname_arr=('.secrets' '.filthy_lucre' '.files' '.information' '.top_secret' '.hidden' '.mystery' '.hidden_treasures' '.maybeinhere' '.treasure_chest');
dirname_arr_len=${#dirname_arr[*]};
dirname='';
#the permissions in numeric form.
correct_permissions=751;
permission_array=(750 777 760 755 701 751);
permission_array_len=${#permission_array[*]};
file_type_correct='text';
file_type_arr=('binary' 'text' 'zero');
file_type_arr_len=${#file_type_arr[*]};
#the file size for the correct one7
correct_size=1337
#padding string function $(printf "%${<bytes_to_pad>}s" "<string>");
file_size_array=(33 1336  29 1338 1337);
file_size_array_len=${#file_size_array[*]};
size=0;
#the owner user id/name.
#1007=hound6
correct_owner=1007
owner_array=(1005 1006 1003 1000 1007);
owner_array_len=${#owner_array[*]};
owner=0;
#1006=hound5 group
correct_group=1006
group=0;
group_array=(1003 1004 1005 1007);
group_array_len=${#group_array[*]};
#the amount of partial matches to include by default it's 1 per directory.
#with the remaining files have random bits of the pattern correct.
red_herrings=directory_number;
#this assumes that file that is correct is counting from 0 like normal.
#this is set for each directory as the file that will be correct.
#the redherring will always be selected as a value that is this value +1 but then
#it wraps around.
correct_file=$(( ($RANDOM % $file_number) ));
red_herring_file=$(( $correct_file+1 ));
if [[ $red_herring_file -gt $(( $red_herring_file - 1 )) ]];
then
red_herring_file=0;
fi
function red_herring_options(){
	local incorrect_file_metadata=$(( $RANDOM % 4));
	local permission=751;
	local owner=1007;
	local group=1006;
	local file_size=1337;

	case incorrect_file_metadata in
	0)
	    permission=${permission_array[$(( $RANDOM % $permission_array_len ))]};
	;;
	1)
	    group=${group_array[$(( $RANDOM % $group_array_len ))]};
	;;
	2)
	   file_size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
	;;
	3)
	   owner=${owner_array[$(( $RANDOM % $owner_array_len))]};
	;;
	esac
#	read -r -a options_array <<< "$permission $owner $group $file_size";
	echo "$permission $owner $group $file_size";
}
function make_false_file(){

    #local FILE_CONTENTS;
    local tmp_str=$(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '=');
    echo -e "$file_type\n size:$size \n$filename$j$suffix";
    case $file_type in
        'text')
            printf "%${size}s\n" "$HOUND6_STR $tmp_str" > "$filename$j$suffix";
        ;;
        'binary')
            dd if=/dev/urandom bs=1 count=$size status=none > "$filename$j$suffix";
        ;;
        'zero')
            dd if=/dev/zero bs=1 count=$size status=none > "$filename$j$suffix";
            ;;
    esac
}

rm -Rvd tmp;
mkdir tmp;
cd tmp;
arr='';
tmp_str='';
FILE_CONTENTS='';
random_number=$(( $RANDOM % $dirname_arr_len ));

echo $correct_file;
echo $red_herring_file;
for ((i=0; i < $directory_number; i++)){
    dirname=${dirname_arr[$(( $RANDOM % $dirname_arr_len )) ]};
    mkdir -v "$dirname$i";
    chmod 777 "$dirname$i";
    cd "$dirname$i";
    filename=${filename_arr[$(($RANDOM % $filename_arr_len))]}${endname_arr[$(($RANDOM % $endname_arr_len))]};
    suffix=${suffix_arr[$(($RANDOM % $suffix_arr_len))]};
    for (( j=0; j < file_number; j++ )){
    size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
    owner=${owner_array[$(( $RANDOM % $owner_array_len ))]};
    group=${group_array[$(( $RANDOM % $group_array_len ))]};
    permission=${permission_array[$(( $RANDOM % $permission_array_len))]};
        if [ $j -eq $correct_file ]; then
            #FILE_CONTENTS=$(printf "%${correct_size}s\n" "$HOUND6_STR $HOUND6_FLAG");
            printf "%${correct_size}s\n" "$HOUND6_STR $HOUND6_FLAG" > "$filename$j$suffix";
            owner=correct_owner; group=correct_group; permission=correct_permission;
        elif [ $j -eq $red_herring_file ]; then
            read -r -a arr <<< $(red_herring_options);
            permission=${arr[0]}; owner=${arr[1]}; group=${arr[2]}; size=${arr[3]};
            tmp_str=$(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '=');
            #FILE_CONTENTS=$(printf "%${size}s\n" "$HOUND6_STR $tmp_str");
            printf "%${size}s\n" "$HOUND6_STR $tmp_str" > "$filename$j$suffix";
        else
            file_type=${file_type_arr[$(($RANDOM % file_type_arr_len))]};
            #FILE_CONTENTS=$(make_false_file $file_size $file_type);
            make_false_file;
        fi
    }
    cd ..;
    #random_number=$(( $random_number+1 ));
    #if [[ $random_number -ge $dirname_arr_len ]];then
    #    random_number=0;
    #fi
}


#false flag function to make a string that looks like the legit one.
#this is used for the redherring's if the length matches up.
# $(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '='); 

