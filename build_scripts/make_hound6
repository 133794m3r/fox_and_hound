#!/bin/bash
#Hound 6 requires them to write their first bash script to bruteforce a pin and then cat that data to a program which'll give them the data back. But it only accepts the pin as a base64 encoded file.
#Macarthur Inbody <mdi2455@email.vccs.edu> (C) 2019-

#TODO: Look into additional options.
HOUND6_FLAG=$( echo 'Phineas the Fox' | openssl dgst -sha1 -binary | base64 | tr -d '=');
HOUND6_STR='The flag is ';
i=0;
j=0;
#HOUND6_FLAG l0pMty8KC2HxqKBni+XzWWm7jfk
#Number of directories.
directory_number=3;
#number of files per directory
file_number=5;
filename_arr=('.-' '-~' '-.' '.~');
filename_arr_len=${#filename_arr[*]};
filename='';
endname_arr=('filename' 'files' 'texts' 'flags');
endname_arr_len=${#endname_arr[*]};
suffix_arr=('.txt' '.dat' '.bin' '.hex' '.file' '.secrets');
suffix_arr_len=${#suffix_arr[*]};
dirname_arr=('.secrets' '.filthy_lucre' '.files' '.information' '.top_secret' '.hidden' '.mystery' '.hidden_treasures' '.maybeinhere');
dirname_arr_len=${#dirname_arr[*]};
dirname='';
#the permissions in numeric form.
correct_permissions=751;
permission_array=(750 777 760 755 701 751);
file_type_correct='text';
file_type_arr=('binary' 'text' 'zeroes' 'null');
#the file size for the correct one7
correct_size=1337
#padding string function $(printf "%${<bytes_to_pad>}s" "<string>");
file_size_array=(33 1336  29 1338 1337);
file_size_array_len=${#file_size_array[*]};
size=0;
#the owner user id/name.
#1007=hound6
correct_owner=1007
owner_array=(1005 1006 1003 1000 1007);
owner_array_len=${#owner_array[*]};
owner=0;
#1006=hound5 group
correct_group=1006
group=0;
group_array=(1003 1004 1005 1007 1006);
group_array_len=${#group_array_len[*]};
#the amount of partial matches to include by default it's 1 per directory.
#with the remaining files have random bits of the pattern correct.
red_herrings=directory_number;
#this assumes that file that is correct is counting from 0 like normal.
#this is set for each directory as the file that will be correct.
#the redherring will always be selected as a value that is this value +1 but then
#it wraps around.
correct_file=$(( ($RANDOM % $file_number) ));
red_herring_file=$correct_file+1;
if [[ $red_herring_file -gt $(( $file_number - 1 )) ]];
then
$red_herring_file=0;
fi
function red_herring_options(){
	local incorrect_file_metadata=$(( $RANDOM % 4));
	local permission=751;
	local group=1006;
	local file_size=1337;
	local owner=1007;
	case incorrect_file_metadata in 
	0)
	    permission=${permission_array[$(( $RANDOM % $permission_array_len ))]};
	;;
	1)
	    group=${group_array[$(( $RANDOM % $group_array_len ))]};
	;;
	2)
	   file_size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
	;;
	3)
	   owner=${owner_array[$(( $RANDOM % $owner_array_len))]};
	;;
	esac
#	read -r -a options_array <<< "$permission $owner $group $file_size";
	echo "$permission $owner $group $file_size";
}
rm tmp/*;
cd tmp;
arr='';
for ((i=0; i -lt directory_number; i++)){
    dirname=${dirname_arr[ $(( $RANDOM % $dirname_arr )) ]};
    chown 1007 "$dirname";
    cd "$dirname";
    for((j=0;j -lt file_number; i++)){
    size=${file_size_array[$(( $RANDOM % $file_size_array_len ))]};
    owner=${owner_array[$(( $RANDOM % $owner_array_len ))]};
    group=${group_array[$(( $RANDOM % $group_array_len ))]};
    permission=${permission_array[$(( $RANDOM % $permission_array_len))]};
        if [[ $j -eq $correct_file ]];
        then
            printf "%${}";
        elif [[ $j -eq $red_herring_file ]];
        then
            read -r -a arr <<< $(red_herring_options)
        fi
    }

}


#false flag function to make a string that looks like the legit one.
#this is used for the redherring's if the length matches up.
# $(echo $RANDOM | openssl dgst -sha1 -binary | base64 | tr -d '='); 

