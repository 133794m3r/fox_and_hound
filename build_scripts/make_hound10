#!/bin/bash
#Hound 10 aka `I have a problem. I know I'll use regex. Now I have 2 problems.`
# Macarthur Inbody <mdi2455@email.vccs.edu>
# AGPLv3
# 2019 -
# This flag requires them to write a regex that will match the line that has a set of strings. They'll be
# having to search for a string that string that contains some pattern of characters they'll pass this an argument
# to a script that'll then run the regex on the file. The string that it gets will then be passed to tr and it'll be
# cut to make sure that it's a good string. Basically they'll be looking for a string that contains a '.', '$','*',' '
# or the one that has it at the front|end. Or the one that's all lowercase or all uppercase.
if [[ $# -lt 1 ]];then
    level=11;
else
    level=$1;
fi
#the library of build functions.
source build_functions;

seed_random $level;
#the dictionary file that we're using to get our words from.
#this will be set to a global variable DICTIONARY from the main script once the whole
#build system is done.
password_dict='../dict/passwords_dict';
#get the length of the dictionary file.
#in the future this'll be calculated once from the main build script and then the string
#DICTIONARY_LEN will be set to this value.
password_dict_len=2007;
#set the encoding. In future versions this'll be hardcoded from the main script.
#this is to make sure tha all hashes are b32 encoded.
HASH_ENCODING='b32';
#make the correct flag string. It's going to be b32 encoded right now. Also right now the flag is always going to be the same string.
FLAG_HOUND=$( make_flag 1);
#continue the RNG;
continue_random;
regex_str=$( select_regex );
false_regex_str=$( select_regex );
false_regex_str1=$( select_regex );
while [[ "$regex_str" = "$false_regex_str" || "$regex_str" = "$false_regex_str1" ]];do
    regex_str=$( select_regex );
done
