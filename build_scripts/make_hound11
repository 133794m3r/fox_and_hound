#!/bin/bash
# Hound 11 aka `I write scripts _in_ my scripts! *INCEPTION SOUND*`
# Macarthur Inbody <mdi2455@email.vccs.edu>
# AGPLv3
# 2019 -
# This flag requires them find a string that is a certain number of characters in length.
# They can use either awk/sed to get the answer here. Then they'll have to select the one
# that does not have some special character in it. There'll only be 2 flags that are the
# correct length as the code to get the right answer is way too complex for a flag.
# This one will require them to run some regex on the file and the regex strings will of course
# be changing so one time it'll be field that ends in a '.' or some other character. or starts with it
# along with the standard regex things to make this a lot more random in the future.
#awk "$0 ~ /^[a-zA-Z]*$/ && length($0) == $LENGTH {print };" `<FILENAME>`;
#sed -n "/.\{$LENGTH,$LENGTH\}/p" `<FILENAME>` | grep -v "[^a-zA-Z]"
#One note is that UPPER_CASE files are meant to be constants that aren't changed after being set.
#lowercase can cahnge whenever.
if [[ $# -lt 1 ]];then
    level=11;
else
    level=$1;
fi
#the library of build functions.
source build_functions;

seed_random $level;
#the dictionary file that we're using to get our words from.
#this will be set to a global variable DICTIONARY from the main script once the whole
#build system is done.
password_dict='../dict/passwords_dict';
#get the length of the dictionary file.
#in the future this'll be calculated once from the main build script and then the string
#DICTIONARY_LEN will be set to this value.
password_dict_len=2007;
#set the encoding. In future versions this'll be hardcoded from the main script.
#this is to make sure tha all hashes are b32 encoded.
HASH_ENCODING='b32';
#make the correct flag string. It's going to be b32 encoded right now. Also right now the flag is always going to be the same string.
FLAG_HOUND=$( make_flag 1);
#continue the RNG;
continue_random;

NUM_LINES=$(( ($RANDOM & 30) + 50 ));
correct_line=$(( ($NUM_LINES & 30 ) + 15 ));
false_line=$(( $correct_line + ($RANDOM  & 15 )));
false_line2=$(( $correct_line - ($RANDOM & 15) ));
while [[ $correct_line -eq $false_line ]];do
    correct_line=$(( ($NUM_LINES & 30 ) + 15 ));
done
#the prefix string. The false flag there'll just be one that's the correct length but also has a ':' or a ',' in it.
#the string will be padded to a certain length and that's what they're using awk for.
FLAG_STRING='your flag is';
regex_str=$( select_regex );
false_regex_str=$( select_regex );
#the strings will be padded with extra spaces at the end of the line.
#The correct one will also be chosen randomly.
max_spaces=25;
correct_spaces=$(( ($RANDOM % $max_spaces)+1 ));
num_spaces=0;


#the filename we're going to use. It's an empty string by default.
filename='';
#The prefixes for the files
filename_arr=('.-' '-~' '-.' '.~' '.mystery' '.hidden_file' 'INHERE' 'README' 'INSIDETHIS' 'FILE' 'SECRET');
#we get the length of the files.
filename_arr_len=${#filename_arr[*]};
filename=${filename_arr[$(( $RANDOM % $filename_arr_len))]};
extra_str=':';
echo -n '' > tmp;
echo 'regex_pattern:'$regex_case;
echo 'regex_str:'"$regex_str";
tmp_str='';
echo "$FLAG_HOUND";
echo 'cl:'$correct_line;
echo 'fl:'$false_line;
echo 'len:'$( printf "%s%${correct_spaces}s\n" "$FLAG_STRING $FLAG_HOUND" | wc -c );
for((i=0;i<NUM_LINES;++i)){
    str=$( make_false_flag $password_dict $password_dict_len );
    num_spaces=$(( $RANDOM % $max_spaces));

    while [[ $num_spaces -eq $correct_spaces ]];do
        num_spaces=$(( $RANDOM % $max_spaces ))
    done

    if [[ $i = $correct_line ]];then
        printf "%s%${correct_spaces}s\n" "$( printf "$FLAG_STRING $FLAG_HOUND" | sed -e "$regex_str" )" ''>> tmp;
    elif [[ $i = $false_line ]];then
        printf "%s%${num_spaces}s\n" "$( printf "$FLAG_STRING $str" | sed -e "$regex_str" )" ''>> tmp;
    elif [[ $i = $false_line2 ]];then
       printf "%s%${correct_spaces}s\n" "$( printf "$FLAG_STRING:$str" | sed -e "$false_regex_str" )" ''>> tmp;
    else
       printf "%s%${num_spaces}s\n" "$( printf "$FLAG_STRING $str" | sed -e "$false_regex_str" )" ''>> tmp;
    fi

}
tmp=$( printf "%s%${correct_spaces}s " "$( printf "$FLAG_STRING $FLAG_HOUND" | sed -e "$regex_str" )"  | wc -c );
echo 'cc:'$(( $tmp - 1 ));
