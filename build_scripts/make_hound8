#!/bin/bash
#Macarthur Inbody <mdi2455@email.vccs.edu> (C) 2019-
#This will be a nano flag. It'll be 2 flags in one. Part will require them to find a 
#specific string that will then tell them what the file name is that they have to
#insert into their text file to then find the flag.
cd ../text_shells/nano;
#CORRECT_FLAG="$( echo "$(shuf -n 1 hound_dict)$HOUND_LEVEL" | openssl dgst -sha1 -binary | b32 )$HOUND_LEVEL";
#currently it's ArticFox8
#CORRECT_FLAG='3ss6xebhdpn8je3xrjce6e6p4rqxmyt4';
CORRECT_FLAG='fIgfIWfZuOQ2jiMIl6iHQHErwak=';
#the false flag is there to make it harder for them to bruteforce the answer.
#FALSE_FLAG='3ss6xebhdpn8je38'
FALSE_FLAG='7avNNl3SZzDUnmVm'
#FALSE_FLAG='1234567890ABCDEF';
SEARCH_STRING0='';
SEARCH_STRING1='';
SEARCH_STRING2='';
FLAG_FILE='';
FLAG_STRING='Your flag is the following base64 encoded string ';
tmp=0;
#removing the build files.
rm -v built_files/*
INSTRUCTIONS0='Your next instructions are located after the string ';
INSTRUCTIONS1='Now you need to read the file ';
#this gets all of the files in the top directory, and then it does an inverse
#grep to remove the .header file from the list of files that are shown. It then
#puts this output into an array.
#nano_files_arr=( $( find . -maxdepth 1 -type f | grep -v './.header' ) );
nano_files_arr=( $(ls | grep -v 'built_files' ) );
#this gives the length of the array the [*]=all items. And doing ${#var} gets you
#the length of the var.
nano_files_arr_len=${#nano_files_arr[*]};

#gets a random number between $RANDOM and n-1.

i=$(( $RANDOM % $nano_files_arr_len ));
#selects a random item from the array.
tmp=${nano_files_arr[$i]};
#starts the string with the value.
cat_str=$tmp;
#increments the value.
i=$(( $i+1 ));
#checks if we've overflowed.
if [[ $i -gt $(( $nano_files_arr_len - 1)) ]];then
    i=0;
fi
#appends to the cat_str variable.
cat_str=$cat_str' '${nano_files_arr[$i]};
i=$(( $i +1 ));
if [[ $i -gt $(( $nano_files_arr_len - 1)) ]];then
    i=0;
fi

cat_str=$cat_str' '${nano_files_arr[$i]};
#the final complete string to be catted.
echo $cat_str;
#this sends the files to the built_files dir and the combined file.
cat $cat_str > built_files/nano_combined;
#changing directory to the directory.
cd built_files;

nano_combined_lines=$(cat nano_combined |  wc -l );
echo $nano_combined_lines;
first_string_line_num=0;
second_string_line_num=0;
third_string_line_num=0;
line_max=$(( $nano_combined_lines/3  ));
echo $lines_max;

first_string_line_num=$(( $RANDOM % $line_max ));
line_max=$(( $line_max * 2 ));
range=$(( $line_max - $first_string_line_num ));
second_string_line_num=$(( ( $RANDOM % $range ) + $first_string_line_num ));
line_max=$(( $nano_combined_lines - 50 ));
range=$(( $lines_max - $second_string_line_num));
third_string_line_num=$(( ($RANDOM % $range) + $second_string_line_num));
line='';
instruction_line=$(( $RANDOM % $nano_combined_lines ));

while [[ $first_string_line_num -eq $instruction_line || $second_string_line_num -eq $instruction_line || $third_string_line_num -eq $instruction_line ]]; do
    instruction_line=$(( $RANDOM % $nano_combined_lines));
done

echo "f:$first_string_line_num s:$second_string_line_num t:$third_string_line_num";
SEARCH_STRING0=$( printf '%5s' $RANDOM | b32 );
SEARCH_STRING1=$( printf '%5s' $RANDOM | b32 );
SEARCH_STRING2=$( printf '%5s' $RANDOM | b32 );
FLAG_FILE=$( printf '%5s' $RANDOM | b32 );

tmp_num=$(($RANDOM % 3));
false_file='';
echo 'il:'$instruction_line;

if [[ $tmp_num -eq 0 ]]; then

    INSTRUCTIONS0="$INSTRUCTIONS0 $SEARCH_STRING0";
    first_string_line_num=$(( $instruction_line + (($RANDOM % 50 ) + 30) ));
    SEARCH_STRING0="$SEARCH_STRING0   $INSTRUCTIONS1 $FLAG_FILE"
    
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FALSE_FLAG$(( $RANDOM % 1000  )) | base64 ) > $false_file;      
    SEARCH_STRING1="$SEARCH_STRING1   $INSTRUCTIONS1 $false_file";
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FLAGFALSE$(( $RANDOM % 1000  )) | base64 ) > $false_file;      
    SEARCH_STRING2="$SEARCH_STRING2   $INSTRUCTIONS1 $false_file";

elif [[ $tmp_num -eq 1 ]];then

    second_string_line_num=$(( $instruction_line + (( $RANDOM % 50 ) + 30) ));
    INSTRUCTIONS0="$INSTRUCTIONS0 $SEARCH_STRING1";
    SEARCH_STRING1="$SEARCH_STRING1   $INSTRUCTIONS1 $FLAG_FILE"
    
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FALSE_FLAG$(( $RANDOM % 1000  )) | base64 ) > $false_file;        
    SEARCH_STRING0="$SEARCH_STRING0   $INSTRUCTIONS1 $false_file";
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FALSE_FLAG$(( $RANDOM % 1000  )) | base64 ) > $false_file;       
    SEARCH_STRING2="$SEARCH_STRING2   $INSTRUCTIONS1 $false_file";
    
elif [[ $tmp_num -eq 2 ]];then

    third_string_line_num=$(( $instruction_line + (($RANDOM % 50 ) + 30) ));
    INSTRUCTIONS0="$INSTRUCTIONS0 $SEARCH_STRING2";
    SEARCH_STRING2="$SEARCH_STRING2   $INSTRUCTIONS1 $FLAG_FILE"
    
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FALSE_FLAG$(( $RANDOM % 1000  )) | base64 ) > $false_file;      
    SEARCH_STRING1="$SEARCH_STRING1   $INSTRUCTIONS1 $false_file";
    false_file=$(printf '%5s' $RANDOM | b32 );
    echo -e "\n$FLAG_STRING"$(printf '%20s' $FALSE_FLAG$(( $RANDOM % 1000  )) | base64 ) > $false_file;        
    SEARCH_STRING0="$SEARCH_STRING0   $INSTRUCTIONS1 $false_file"
    
fi
while [[ $first_string_line_num -eq $instruction_line || $second_string_line_num -eq $instruction_line || $third_string_line_num -eq $instruction_line ]]; do
    instruction_line=$(( $RANDOM % $nano_combined_lines));
done
OUTPUT_FILE='nano_combined_built';
#i=27;
i=27;
echo $INSTRUCTIONS0;
#echo $SEARCH_STRING0;
#echo $SEARCH_STRING1;
#echo $SEARCH_STRING2;
echo '' > $OUTPUT_FILE;
while read line; do

    if [[ $i -eq $first_string_line_num ]]; then
    
        echo -e $SEARCH_STRING0 >> $OUTPUT_FILE;
        echo 'fj:'$i;
     #   let "j++";
        let "i++";
        
    elif [[ $i -eq $second_string_line_num ]]; then
    
        echo -e $SEARCH_STRING1 >> $OUTPUT_FILE;
        echo 'sj:'$i;
        let "i++";
#        let "i++";

    elif [[ $i -eq $third_string_line_num ]]; then
    
        echo -e $SEARCH_STRING2 >> $OUTPUT_FILE;
        echo 'ti:'$i;
  #      let "j++";
        let "i++";
        
    elif [[ $i -eq $instruction_line ]]; then
    
        echo -e $INSTRUCTIONS0  >> $OUTPUT_FILE;
        instruction_line1=$i;
    #    echo 'ii:'$i;
        echo 'ii:'$i;
        let "i++"; 
     #   let "i++";
     
    fi
    let "i++";
    
    #let "j++";
    echo -e "$line" >> $OUTPUT_FILE;
    
done < nano_combined;

#this is because cat will complain if we try to redirect to the same file.
cat '../.header' $OUTPUT_FILE > "$OUTPUT_FILE-1";
#then we move it back again.
mv "$OUTPUT_FILE-1" 'nano_welcome_msg';
num_8=$( printf '%5s%s' 8 '');

#this makes sure that it's got the correct number of spaces to make it all
#aligned the right way.
padding=$(( 18 - ${#instruction_line1}  ));
format_str="%s%${padding}s";

format_str="$(printf $format_str $instruction_line1 '')";

#the final editing of the file.
#this line is to modify the line the instruction are at.
sed -i "s/<instruction_line>/$format_str/g" $OUTPUT_FILE;
#this line is there to set the level for the flag. Right now it's just 8 but
#technically it's gonna be called text0 for class.
sed -i "s/<num>/$num_8/g" $OUTPUT_FILE;
#finally set the real flag's file and we're done.
echo -e "\n$FLAG_STRING$CORRECT_FLAG" > $FLAG_FILE;
rm -v nano_combined;
rm -v ../../../hounds/hound8/*;
cp -v * ../../../hounds/hound8;
