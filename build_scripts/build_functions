#!/bin/bash
# Various Functions that I'm utilizing in the build scripts to simplify everything and keep it DRY.
# Macarthur Inbody <mdi2455@email.vccs.edu>
# 2019-

# debug_random
# arg=NULL.
# This function is for debug purposes and starts the RNG always at 1 for the very start.
function debug_random(){
    RANDOM=1;
}

# seed_random
# arg=<NUMERIC_VALUE_TO_SEED_WITH>
# This functions seeds random with a value that's been given to it as an argument and is the first one.
# this'll be utilized for when it's making tests and deciding how to seed it.
function seed_random(){
    RANDOM=$1;
}

# continue_random
# arg=NULL;
# this function makes random output more random numbers by seeding it with a random(ish) number.
# it's primary use for when we're doing partial rebuilds/building tests.
function continue_random(){
# here we are setting the seed value to the current number of nanoseconds that are on the clock from date.
# via it's format string, then capturing that input from the subshell, expanding it to a value and then we
# are setting it to the variable seed. And since variables are global by default we are setting it as local
# so that in case the variable seed is every set anywhere else it won't overwrite it.
    local seed=$( date +%N );
    RANDOM=$seed;
}

# this function is the hash maker which right now just outputs the b64 encoded sha1 hash.
# also it reads from stdin, that's why there's nothing at the front it just starts going.
function mk_hash(){
# You can imagine an invisible `cat stdin |` operator at the front if it helps you realize what's going on here.
    if ! [ $HASH_ENCODING ]; then
        openssl dgst -sha1 -binary | base64 | tr '\/+' '_-';
        #if it's set to b32
    elif [ $HASH_ENCODING = 'b32' ]; then
        openssl dgst -sha1 -binary | b32;
    else
        #default case.
        openssl dgst -sha1 -binary | base64;
    fi
}
#this function gets words of a certain length that are valid ASCII I include control characters in the grepping for simplicity's sake.
function get_certain_words(){
#the ake command makes sure that the length of the file it's reading line by line column $0=first columnt is equal to the
#second argument's length then we grep all ASCIi characters it could've been a single command.
# \x00-\x7f=0-127 aka valid ASCII characters.
    awk 'length($0) == '"$2"'' "$1" | grep  -P -v '[^\x00-\x7f]'
}
#this selects a random word from the dictionary that's passed to it as argument 1, argument 2 is that dictionaries length.
#argument 3 is whether it's going to chose the same for testing purposes.
function get_random_word(){
#eventually add the option to make the word be a set length which'll be this command.
#sed -ne '/.\{8\}$/p' /usr/share/dict/american-english  | sed -n '<LINE_NUM> p';

#if arguments are greater than or equal to 3 and the third argument is true/1.
    if [ $# -ge 3 ]; then
        if [ $3 = 1 ]; then
            #seed random with the global variable $level
        seed_random $level;
        fi
    fi
    #local variables ot make it easier to read.
    local dict=$1;
    local dict_len=$2;
    #get lines  1-file_length as sed is 1 index based.
    local rnd_line=$((  ( $RANDOM % $dict_len )+1 ));
    #local password=$( sed -n "$rnd_line p" $dict_file );
    #printf $password;
    #use sed in address mode.
    sed -n "$rnd_line p" $dict;
}
function make_false_flag(){
    if [ $# -ge 3 ]; then
        seed_random $level;
    fi

    local dict=$1;
    local dict_len=$2;
    local rnd_line=$((  ( $RANDOM % $dict_len )+1 ));
    local password=$( sed -n "$rnd_line p" $dict );
    printf $password | mk_hash;
}
make_flag(){
    if [ $# -ge 1 ];then
        seed_random $level;
    fi
# The level will be hex-encodded to reduce character count and make easier to bruteforce the password(for now).
    local hex_num=$( printf '%x' $1 );
# the dictionary file right now it's not checking which set of flags are being built.
# it will have a case switch for the dictionaries later.
    local dict_file='../dict/hound_dict';
# we get the number of lines from the file since it can change.
    local max_line=$( cat $dict_file | wc -l);
# we use random to select a random line and add one to it so that we get a valid range for sed.
# since sed counts from 1 for whatever reason.
    local rnd_line=$((  ( $RANDOM % $max_line )+1 ));

# then we use sed in address mode to selct the line from the file, and including levelnum encoded
# as hex previously.
    local password=$( sed -n "$rnd_line p" $dict_file )$1;
    #sed -n "$rnd_line p" $dict_file;
# pass it to string to the hash function.
# then we b64 encode it, then we use tr to delete the trailing '='s and finally replace the characters to make
# it safe for putting into directories. How it's captured is just by doing it like any other command it'd be something like.
# <NAME><LEVEL>_FLAG=$( make_flag <NUMERIC_LEVEL>);
    printf '%s' $password | mk_hash;
}
#this function will eventually actually do something.
#it'll select a random element from an array but for now it does nothing.
function get_random_element(){
    return 0
}

function select_regex(){
    # the options for the regex. It sets the regex pattern for the string.
    # 0=all lowercase characters. 1=starts with uppercase. 2=starts with number. 3=starts with special character.
    # 4=ends with a number. 5=ends with a special character. 6=ends with a capital character. 7=ends with a lowercase letter.
    regex_case=$(( $RANDOM & 7 ));
    regex_str='';
    tmp=0;
    case $regex_case in
        0)
            regex_str='s/\(.*\)/\L\1/';
        ;;
        1)
            regex_str='s/\(^[a-z]\)/\U\1/';
        ;;
        2)
            tmp=$(( $RANDOM & 9 ));
            regex_str="s/\(^[a-z]\)/$tmp\1/";
        ;;
        3)
            tmp=$(( $RANDOM & 4 ));
            case $tmp in
                0)
                    tmp='\.';
                ;;
                1)
                    tmp='\#';
                ;;
                2)
                    tmp='\@';
                ;;
                3)
                    tmp='\:';
                ;;
                4)
                    tmp='\_';
                ;;
            esac;
            regex_str="s/\(^[a-z]\)/$tmp\1/";
        ;;
        4)
            tmp=$(( $RANDOM & 9 ));
            regex_str="s/\(.*$\)/\1 $tmp/";
        ;;
        5)
            tmp=$(( $RANDOM & 4 ));
            case $tmp in
                0)
                    tmp='\.';
                ;;
                1)
                    tmp='\#';
                ;;
                2)
                    tmp='\@';
                ;;
                3)
                    tmp='\:';
                ;;
                4)
                    tmp='\_';
                ;;
            esac;
            regex_str="s/\(.*\)/\1$tmp/";
        ;;
        6)
            tmp=$(( ($RANDOM  & 25 ) + 65 ));
            tmp=$( perl -e "printf '%c',$tmp;" );
            regex_str="s/\(.*\)/\1 $tmp/";
        ;;
        7)
            tmp=$(( ($RANDOM  & 25 ) + 97 ));
            tmp=$( perl -e "printf '%c',$tmp;" );
            regex_str="s/\(.*\)/\1 $tmp/";
        ;;
    esac
    echo "$regex_str";
}
