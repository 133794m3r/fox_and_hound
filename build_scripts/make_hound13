#!/bin/bash
# Hound ??: Work it, let me work it. Flip it and reverse it. ti tuc ,ti rt ,ti ver ,ti qinu ,ti troS
# This hound flag will combine the following commands into one. They'll sort a file, then get the only uniq
# line. After that, reverse the string, tr it from mixed-case to lowercase. Then the flag is the second field.
# so if they use cut they can instantly get it.
# Macarthur Inbody
# mdi2455@email.vccs.edu / admin-contact@transcendental.us
# Licenesed under AGPLv3
# (C) 2019 -

HASH_ENCODING='b32';
if [[ $# -lt 1 ]];then
    level=15;
else
    level=$1;
fi
source build_functions;
WORD_ARRAY=(25 24 23 22 21 20 19);
tmp_rnd=`( dd if=/dev/urandom bs=2 count=1 status=none | od -A n -t u )`;
chosen_word=${WORD_ARRAY[$(( $tmp_rnd % 7 ))]};
FLAG_HOUND=$( make_semistatic_flag $chosen_word);
#the dictionary file that we're using to get our words from.
#this will be set to a global variable DICTIONARY from the main script once the whole
#build system is done.
dictionary='../../dict/passwords_dict';
#get the length of the dictionary file.
#in the future this'll be calculated once from the main build script and then the string
#DICTIONARY_LEN will be set to this value.
dictionary_len=2007

#the filename we're going to use. It's an empty string by default.
filename='';
#The prefixes for the files
filename_arr=('.-' '-~' '-.' '.~' 'this file has spaces' 'spaces in the name' 'INHERE' 'README' 'INSIDETHIS' 'FILE' 'SECRET');
#we get the length of the files.
filename_arr_len=${#filename_arr[*]};
filename_ext_arr=('.txt' '.dat' '.md' '.notes' .'flag');
filename_ext_arr_len=${#filename_ext_arr[*]};

filename=${filename_arr[$(( $RANDOM % $filename_arr_len ))]}${filename_ext_arr[$(( $RANDOM % $filename_ext_arr_len))]};

